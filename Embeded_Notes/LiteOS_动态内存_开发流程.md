# LiteOS 动态内存 开发流程
## 在 los_config.h 文件中配置动态内存池的起始地址和大小
| 配置项          |                             含义                              | 取值范围 | 默认值                   | 依赖 |
| --------------- |:-------------------------------------------------------------:| -------- | ------------------------ | ---- |
| OS_SYS_MEM_ADDR |                     系统动态内存起始地址                      | \[0～n)  | &m_acuSysMem1\[0]        | 无   |
| OS_SYS_MEM_SIZE | 系统动态内存池的大小</br>(DDR自适应配置)</br>以 `byte` 为单位 | \[0~n)   | 从bss段末尾至系统DDR末尾 | 无   |

两个参数一般使用默认值即可

## 通过 make menuconfig 配置动态内存管理模块
内核配置参数详情参考 [[LiteOS_动态内存_API]] 的最后一个


## 初始化 LOS_MemInit
初始一个内存池后如图，生成一个 EndNode，并且剩余的内存全部被标记为FreeNode节点。注：EndNode作为内存池末尾的节点，size为0。

![[Pasted image 20210906162519.png]]

## 申请任意大小的动态内存
通过 LOS_MemAlloc 接口函数申请动态内存  

判断动态内存池中是否存在申请量大小的空间
+ 若存在，则划出一块内存块，**以指针形式返回**
+ 若不存在，返回NULL。

调用三次 LOS_MemAlloc 函数可以创建三个节点，加入分别为 UsedA，UserB，UserC，大小分别为sizeA，sizeB，sizeC。因为刚初始化内存池的时候只有一个大的FreeNode，所以这些内存块是从这个FreeNode中切割出来的。

![[Pasted image 20210906162813.png]]

当内存池中存在多个FreeNode的时候进行malloc，将会适配最合适大小的FreeNode用来新建内存块，减少内存碎片。若新建的内存块不等于被使用的FreeNode的大小，则在新建内存块后，多余的内存又会被标记为一个新的FreeNode。

## 释放动态内存 
通过 LOS_MemFree 接口函数动态释放内存  
回收内存块，以供下一次使用

![[Pasted image 20210906163050.png]]


> 上述API没有平台差异性


## 使用注意  
+ 动态内存管理需要管理控制块数据结构来管理内存
	+ 这些数据结构会额外消耗内存
	+ 故实际用户可使用内存总量小于配置项OS_SYS_MEM_SIZE的大小
+ 对齐分配内存接口LOS_MemAllocAlign/LOS_MemMallocAlign因为要进行地址对齐
	+ 可能会额外消耗部分内存，故存在一些遗失内存
	+ 当系统释放该对齐内存时，同时回收由于对齐导致的遗失内存 
+ 重新分配内存接口LOS_MemRealloc/LOS_MemMrealloc
	+ 如果分配成功,系统会自己判定是否需要释放原来申请的内存，并返回重新分配的内存地址
	+ 如果重新分配失败，原来的内存保持不变，并返回NULL
	+ 禁止使用 `pPtr = LOS_MemRealloc(pool, pPtr, uwSize)`
		+ 即：不能使用原来的旧内存地址pPtr变量来接收返回值。
+ 对同一块内存多次调用LOS_MemFree/LOS_MemMfree
	+ 第一次会返回成功
	+ 同一块内存多次重复释放会导致非法指针操作，结果不可预知
+ 由于动态内存管理的内存节点控制块结构体LosMemDynNode中
	+ 成员sizeAndFlag的数据类型为UINT32，高两位为标志位
	+ 余下的30位表示内存结点大小
	+ 因此用户初始化内存池的大小不能超过1G，否则会出现不可预知的结果。

