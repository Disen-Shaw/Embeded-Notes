# FreeRTOS队列
在实际应用中会遇到一个任务或者中断服务需要和另一个任务进行“沟通交流”，这个“沟通交流”的过程其实就是消息传递的过程。在没有操作系统的时候两个应用程序进行消息传递一般使用**全局变量**的方式，但是如果在使用操作系统的应用中用全局变量来传递消息就会涉及到“**资源管理**”的问题。

## 队列简介
队列是为了**任务与任务**、**任务与中断之间**的通信而准备的
可以在**任务与任务**、**任务与中断之间**传递消息，队列中可以存储**有限**的、**大小固定**的数据项目。
**任务与任务、任务与中断之间要交流的数据保存在队列中，叫做队列项目**。队列所能保存的最大数据项目数量叫做队列的长度，创建队列的时候会指定数据项目的大小和队列的长度。
由于队列用来传递消息的，所以也称为消息队列。
FreeRTOS 中的信号量的也是依据队列实现的


### 数据结构
#### FIFO类型
通常队列采用先进先出(FIFO)的存储缓冲机制，也就是往队列发送数据的时候(也叫入队)永远都是发送到队列的尾部，而从队列提取数据的时候(也叫出队)是从队列的头部提取的。
#### LIFO
但是也可以使用 LIFO 的存储缓冲，也就是**后进先出**，FreeRTOS 中的队列也提供了 LIFO 的存储缓冲机制，类似于栈

#### 传值方式
数据发送到队列中会导致数据拷贝，也就是将要发送的数据拷贝到队列中，这就意味着在队列中存储的是数据的原始值，而不是原数据的引用(即只传递数据的指针)，这个也叫做值传递。
UCOS 的消息队列采用的是引用传递，传递的是消息指针。采用引用传递的话消息内容就必须一直保持可见性，也就是消息内容必须有效，那么局部变量这种可能会随时被删掉的东西就不能用来传递消息，但是采用引用传递会节省时间，因为不用进行数据拷贝。

采用值传递的话虽然会导致数据拷贝，会浪费一点时间，但是一旦将消息发送到队列中原始的数据缓冲区就可以删除掉或者覆写，这样的话这些缓冲区就可以被重复的使用。

FreeRTOS中使用队列传递消息的话虽然使用的是数据拷贝，但是也可以使用引用来传递消息，直接往队列中发送指向这个消息的地址指针就可以了。
这样当我要发送的消息数据太大的时候就可以直接发送消息缓冲区的地址指针，比如在网络应用环境中，网络的数据量往往都很大的，采用数据拷贝的话就不现实。

### 多任务访问
队列不是属于某个特别指定的任务的，任何任务都可以向队列中发送消息，或者从队列中提取消息。

### 出队阻塞
当任务尝试从一个队列中读取消息的时候可以指定一个阻塞时间，这个阻塞时间就是当任务从队列中读取消息无效的时候任务阻塞的时间。
**出队就是就从队列中读取消息，出队阻塞是针对从队列中读取消息的任务而言的。**

例如：
任务 A 用于处理串口接收到的数据，串口接收到数据以后就会放到队列 Q 中，任务 A 从队列 Q 中读取数据。如果此时Q是空的，说明还没有数据，任务A这个时候读取是获取不到数据的。
此时任务A有三种处理方式：
+ 不等待
+ 等待一定时间
+ 一直阻塞等待下去

这三中情况由**阻塞时间**决定，这个阻塞时间单位是时钟节拍数。