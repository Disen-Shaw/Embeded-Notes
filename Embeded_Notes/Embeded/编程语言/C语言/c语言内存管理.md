# C语言内存管理
## 作用域

C语言变量的作用域分为：

+ 代码块作用域(代码是{}之间的一点代码)
+ 函数作用域
+ 文件作用域

**局部变量**

也叫auto变量(auto可写可不写)，一般情况下代码块{}内定义的变量都是自动变量

+ 作用域：从变量定义到函数结束
+ 如果没有赋初值，内容为随机

**全局变量**

定义在函数外部

+ 作用域

  整个项目中所有文件

  如果在其他文件使用需要声明(extern关键字)

+ 生命周期：从程序创建到程序销毁

数据在操作时采用就近原则

**静态(static)变量**

+ 作用域也是在定义的函数内有效
+ 生命周期和程序运行周期一样
  **static局部变量的值只初始化一次，但是可以赋值多次。**
+ static局部变量若未赋初始值，则由系统自动赋值
  数值变量自动赋值为0,字符变量赋空字符

~~~c
// 静态局部变量
static int a = 10;
// 在数据区进行存储
~~~

| 变量类型     | 作用域           | 生命周期             | 存储位置 |
| ------------ | ---------------- | -------------------- | -------- |
| 局部变量     | 函数内部         | 从创建到函数结束     | 栈区     |
| 全局变量     | 项目中的所有文件 | 从程序创建到程序销毁 | 数据区   |
| 静态局部变量 | 函数内部         | 从程序创建到城西销毁 | 数据区   |
| 静态全局变量 | 定义所在的文件   | 从程序创建到城西销毁 | 数据区   |

+ 局部变量未初始化，值为任意值。
+ 为初始化的静态局部变量，值为0。

## 内存布局

**内存分区**

C代码经过预处理，编译，汇编和链接后生成一个可执行程序
在Windows下，程序是一个普通的可执行文件

在没有运行程序前，可执行程序内部已经分好三段信息，分别为**代码区**、**数据区**和**未初始化数据区**

+ 代码区

  存放CPU执行的机器指令。
  通常代码区是可以共享的(另外执行的程序可以调用它)
  因为对于频繁执行的程序，只需要在内存中一份代码就行

  代码区只读

+ 全局初始化数据区(data段)

  包含了在程序中明确被初始化的全局变量、已经初始化的静态变量(包括全局静态变量和局部静态变量)和常量数据(如字符串常量)

+ 未初始化数据区(bss区)

  存入的事全局为初始化变量和为初始化静态变量

  为初始化数据区在程序开始执行之前被内核初始化为0或者初始化为空(NULL)

+ 栈区

  先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序的运行过程中加载和释放
  局部变量的生存周期为申请到释放该段栈空间

+ 堆区

  堆是一个大容器，容量远大于栈，但没有栈那样先进后出的顺序。

  用于动态分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

**程序在加载到内存前，代码区(data)和全局区(bss)的大小就是固定的，程序运行期间不能改变**。

**运行可执行程序，系统吧程序加载到内存，除了根据可执行程序的信息分出代码区(test)、数据区(data)和为初始化数据区(bss)之外，还额外增加了堆区和栈区**

## 全局函数和静态函数

在C语言中函数默认都是全局的，使用static可以讲函数生命为静态，函数定义位static就意味着这个函数只能在定义这个函数的文件中使用，对于不同文件中static函数名字可以相同。

~~~c
// main.c
#include<stdio.h>
extern int va;
extern int getG(void);
extern int getO(void);
int main(void)
{
    printf("va = %d\n",va);
    printf("getG = %d\n",getG());
    printf("getO = %d\n",getO());
    printf("getG = %d\n",(getG()*getO()));
}
// fun1.c
int va = 7;
int getG(void)
{
    int va = 20;
    return va;
}
// fun2.c
static int va = 10;
static int getOG(void)
{
    return va;
}
~~~

**全局函数**

全局函数的名称是作用域中唯一的

作用域：在整个项目中所有文件中使用

**静态函数**

静态函数可以和全局函数重名，采用就近原则

生命周期：从程序创建到程序销毁。

| 函数类型 | 作用域                               | 生命周期             | 存储位置                           |
| -------- | ------------------------------------ | -------------------- | ---------------------------------- |
| 全局函数 | 项目中所有文件，在其他文件中最好声明 | 从程序创建到程序销毁 | 没唤醒：**代码区**<br />唤醒：栈区 |
| 静态函数 | 定义所在文件中                       | 从程序创建到程序销毁 | 代码区                             |

### 总结

| 类型           | 作用域     | 生命周期         |
| -------------- | ---------- | ---------------- |
| auto变量       | 一对{}内   | 当前函数         |
| static局部变量 | 一对{}内   | 整个程序运行期间 |
| extern变量     | 整个程序   | 整个程序运行期间 |
| static全局变量 | 当前文件内 | 整个程序运行期间 |
| extern函数     | 整个程序   | 整个程序运行期间 |
| static函数     | 当前文件内 | 整个程序运行期间 |
| register变量   | 一对{}内   | 当前函数         |
| 全局变量       | 整个程序   | 整个程序运行周期 |

## 数据存储位置

内存模型

### 代码区特点：

+ 程序执行二进制码(程序指令)
+ **共享**
+ **只读**

### 数据区特点：

1. 初始化数据区(data段)
2. 为初始化数据区(bss段)
3. 常量区
   + 字符串常量
   + const修饰的常量
   + \#define定义的常量
   + **有的是只读的，有的是可读可写的**
4. 数据区加载信息和数据同生共死

### 栈区特点：

1. 系统为程序分配一个**临时空间**

2. 存储：

   + 局部变量
   + 函数信息
   + 函数参数
   + 数组、指针

3. 栈区大小为1M

   在Windows中可以扩展到10M

   在Linux中可以扩展到16M

### 堆区特点：

1. 存储公共数据、大数据、图片、音乐、视频文件

2. 需要手动开辟空间，结束要手动释放

   开辟：malloc、colloc、realloc

   释放：free

3. 通过指针操作数据

## 内存分部

**从低地址**

+ 代码区

+ 数据区

  + 初始化数据区
  + 从常量区

  + 到data
  + 再到未初始化数据区bss

+ 堆区

  一个大容器，容量远大于栈，但是没有栈的顺序
  用于动态分配内存

+ 栈区

  + 从高地址往低地址存储
  + 先进后出
  + 后进先出

![[Pasted image 20210308190739.png]]

## 堆区内存的分配和释放

### 开辟堆空间存储数据

1. malloc函数

~~~c
#include <stdlib.h>
void *malloc(size_t size);
功能：
    在内存的动态存储区中分配一块长度为size字节的连续区域用来存放类型说明服指定的类型
    分配的孽畜空间不确定，一般使用memset初始化
参数：
    size：需要动态分配内存大小，字节
返回值：
    成功：分配空间的起始地址值
    失败：NULL
~~~

+ 使用过程就是指针操作的过程

### 内存操作函数

1. memset()

~~~c
#include <string.h>
void memset(void *s,int c,size_t n);
功能：
    将s的内存区域的前n个字节以参数c填入
参数：
    s：需要操作内存s的首地址
    c：填充的字符，c虽然是int，但是必须是unsigned char范围内
返回值：s的首地址
~~~

2. memcpy()

   用法和strcpy类似，但是内存拷贝不会考虑\0

~~~c
#include <string.h>
void memcpy(void *s1,void *s2,size_t n);
功能：
    将s2的内存区域的前n个字节拷贝到s1中
参数：
    s1：目的操作地址
    s2：源操作地址
    s1和s2地址尽量不能重叠，否则可能发生错误
返回值：
    s1的首地址
~~~

3. memmove()

~~~markdown
> memmove用法和memcpy类似，但是不会报错
但是效率不高
~~~

4. memcmp()

~~~c
int memcmp(const void *s1,const void *s2,size_t n);
功能：
    比较s1和s2的前n个字符是否相等
返回值：
    相等：0
    大于：> 0
    小于：< 0
~~~