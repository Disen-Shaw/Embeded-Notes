# C++继承
**继承是面向对象的三大特性之一**
形象案例
![[Pasted image 20210406155948.png]]
继承的好处：减少重复的代码
## 语法
~~~c++
class 子类: 继承方式 父类{}
~~~
子类也称为派生类
父类也称为基类
派生类成员，包含两部分
一类时从基类继承过来的，一类是自己增加的成员
从基类继承过来的表现其共性，新增的成员表现其个性

## 继承方式
继承方式一共分为三种：
+ 公共继承
+ 保护继承
+ 私有继承

![[Pasted image 20210406161606.png]]
public继承：
父类中的public和protect权限将继承到子类中，权限不改变。
protected:
父类中的共有成员到子类变成保护成员
private:
父类中的所有可继承成员全部编程私有

**可以套娃**

## 继承中的对象模型
从父类继承过来的成员，属于子类对象
父类中所有的非静态成员属性都会被子类继承下去
父类中私有成员属性是被编译器隐藏，因此访问不到，但是确实被继承下去了


## 继承中的构造和析构顺序
子类继承父类后，当创造子类对象，也会调用父类的构造函数
### 子类和父类的构造和析构函数的调用顺序
在继承中，创建子类对象时会先调用父类对象的构造函数然后调用子类对象的构造函数，结束时调用子类函数的析构函数，最后调用父类函数的析构函数。

~~~c++
class Base
{
private:
    /* data */
public:
    Base()
    {
        cout << "这是父类的构造函数" << endl;
    }
    ~Base()
    {
        cout << "这是父类的析构函数" << endl;
    }
};

class Son : public Base
{
private:
public:
    Son()
    {
        cout << "这是子类的构造函数" << endl;
    }
    ~Son()
    {
        cout << "这是子类的析构函数" << endl;
    }
};

~~~

## 继承同名成员处理方式
当子类与父类出现同名成员时的处理方式
访问子类同名成员:直接访问
访问父类同名成员:需要加作用域

当父类成员中出现重载函数时，子类引用父类的重载函数需要加作用域

~~~c++
class Base
{

public:
    int m_Var;
    Base();
    ~Base();
    void func()
    {
        printf("父类的功能函数\n");
    }
    void func(int)
    {
        printf("父类的带参功能函数\n");        
    }
};
class Son : public Base
{
public:
    Son();
    ~Son();
    int m_Var = 200;
    void func()
    {
        printf("子类的功能函数\n");
    }
};

int main(int argc, char const *argv[])
{
    Son a;
    // a.func(2);
    a.func();
    a.Base::func(2);
}
~~~


## 继承中同名的静态成员的处理方法
继承中同名静态成员在子类中的访问情况
静态成员和非静态成员出现同名，处理方式一样
静态成员在类内声明，在类外定义

子类可以改变父类中的静态成员的状态(指向同一片内存)
子类静态成员与父类静态成员出现同名时，普通的情况(不加作用域)只会操作子类的静态变量

~~~c++
public:
    int m_Var1 = 100;
    static int m_Var2;
};
class Son:public Base{
public:
    int m_Var1 = 300;
    static int m_Var2;
};
int Son::m_Var2 = 9;
int main(void)
{
    Son a;
    cout<<a.m_Var2<<endl;
    cout<<Son::Base::m_Var2<<endl;
    cout<<a.Base::m_Var2<<endl;
    a.func();
    a.Base::func(1);
}
~~~

## 多继承语法
C++允许一个类继承多个类
语法：class 子类名::继承方式 父类1，继承方式 父类2 ...

多继承可能会引发父类中有同名成员函数出现，需要加作用域进行区分
`C++实际开发中不建议使用多继承`

在多继承中含有重名成员时，会报错说不明确，需要添加作用域




## 菱形继承
![[Pasted image 20210408145318.png]]
菱形继承的问题：
羊继承了动物的数据，羊驼同样继承了动物的数据，当羊驼使用数据时，**会产生二义性**

利用虚继承可以解决菱形继承的问题
**关键字：virtual**
在继承之前加上关键字 virtual 变成虚继承
此时，动物的类叫做虚基类
`感觉像是覆盖`

vbptr：虚基类指针
指向vbtable：虚基类表

底层实现：
vbptr继承了指针的偏移量，当继承了多个类时，会根据指针的偏移量寻找对应的值，在两个父类中拿到的只是指针

会占用内存，影响效率



















