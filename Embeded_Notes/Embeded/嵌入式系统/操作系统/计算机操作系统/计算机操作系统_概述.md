# 操作系统概述
## 什么是操作系统
操作系统是一个复杂的系统软件，没有一个完整、精确、公认的定义
### 从用户的角度
操作系统是一个控制软件，它可以
+ 控制、管理应用程序
+ 为应用程序提供服务，IO服务、硬件设备的访问、资源的分配调度等
+ 杀死应用程序

### 资源管理
操作系统是计算机的资源管理器
+ 管理外设、分配资源，保证资源的利用率等功能
+ 底层资源分配

## 操作系统定位
操作系统上层对接进程、文件和地址空间，下层对CPU、磁盘和内存等的硬件进行驱动
操作系统在层次结构上在硬件之上、应用程序之下，是一个中间层的系统软件

Linux、Windows、Android的界面属于外壳(Shell)，而不是内核(Kernel)
Kernel是操作系统的重点，在Shell之下

## Kernel
操作系统最主要的三个功能：
CPU的管理、内存的管理、文件系统的管理
Kernel是操作系统内部组件，包括
+ CPU调度器
+ 物理内存管理
+ 虚拟内存管理
+ 文件系统管理
+ 中断处理与设备驱动，与底层硬件直接打交道

### 操作系统内核的特征
#### 并发
并发指`一段时间`内有多个程序可以运行
并行指`一个时间点`上有多个程序可以同时运行

计算机系统中同时存在多个运行的程序，需要操作系统管理和调度

#### 共享
"同时"访问
互斥共享


#### 虚拟
操作系统直接面对的是硬件，将硬件虚拟化，例如
+ 把CPU虚拟化成进程
+ 把磁盘虚拟化成文件
+ 把内存虚拟化成地址空间

使得每个用户都觉得有一个计算机专门为其服务

#### 异步
程序的执行不是一贯到底，而是走走停停的，向前推进的速度不可预知
只要是运行环境相同，有相同的输入环境，操作系统就需要保证程序运行的结构也相同


## 学习操作系统意义
操作系统结合了不同的课程，进行了进一步的总结、归纳和提升
+ 程序设计语言
+ 数据结构
+ 算法
+ 计算机体系结构

已经有很多操作系统，例如Windows、Linux
但是操作系统还在不停发展、在工控领域有很多需求

### 操作系统需要权衡
+ 空间与时间
+ 性能和可预测性
+ 公平和性能

### 硬件方面，操作系统需要
+ 良好的硬件管理
+ 合理的资源分配
+ 硬盘速度与CPU、内存速度相差很多，操作系统需要协调处理


## 操作系统学习方法
动手实现操作系统的代码
加以自己的思考


## 操作系统实例
操作系统多种多样，对不同的应用场景完成不同的需求
Unix家族、Linux家族(类Unix系统)、Windows家族

## 操作系统发展历史
从1981年到2012年计算机系统的对比
![[Pasted image 20210601015719.png]]
硬件的内存，运算速度以及价格都发生了巨大的变化

### 远古时期
早期计算机使用纸带传输程序和数据，操作系统只起到加载作用
需要手工进行纸带(任务)切换以及输入输出

### 批处理阶段 
CPU等硬件快速发展，计算机速度得到提升，但是性能未得到充分利用
支持流水的调度，自动进行输入输出

### 并发阶段，多道程序设计
内存越来越大，IO速度远低于CPU的运算速度，可以在一个程序IO的空余时间进行另一个程序的运算处理，CPU执行多个程序
如果操作系统处理结构发放为IO处理已经完成，则会产生一个中断，进而进行任务切换调度

### 分时系统
为了更好的利用计算机资源，并且更好的和`用户交互`，出现了分时系统
时间片轮转，时钟外设定期产生中断，帮助操作系统来完成分时调度

### 个人电脑操作系统
+ 单用户
+ 利用率已经不再是关注点
+ 重点是用户界面和API
+ 很多服务功能不存在

#### 演变
+ 最初
	+ 操作系统作为一个简单的服务提供者(简单核)

+ 现在
	+ 支持协调和沟通的多应用系统
	+ 越来越多的安全问题浮现出来


### 进一步发展
#### 多核多处理器
操作系统支持多核心多线程

#### 分布式操作系统
随着网络的发展，出现了分布式操作系统
用户只给了一个前端，很多的计算和存储工作是由数据中心来帮助运算的
中间通过网络链接
+ 松、紧耦合系统

### 将来
嵌入式设备崛起，大量嵌入式设备涌现，用于云计算技术

## 操作系统的结构
### 操作系统底层
+ 定时器驱动
+ 引导装载(Bootloader)
+ 中断服务

### 简单的操作系统 :MS-DOS(1981-1994)
不分模块的单体内核

### 微内核
尽可能把内核功能移入用户空间，只在操作系统内核存放最基本的功能
松耦合架构

#### 内核
+ 中断处理
+ 消息传递等

#### 外部模块
+ 文件系统
+ 内存管理
+ 网络协议栈等服务

服务与服务之间通过内核的消息传递机制

代价是性能，要先将服务内容导入内核，再给请求端，会浪费性能

### 外核架构(鸿蒙?)
将内核分为两部分
一块和硬件打交道，完成硬件功能的复制，这部分称为外核
另一块建立在外核之上，与具体应用打交道
如果有请求，先到外核找到相应的模块?再通过外核来控制硬件

优点是速度快

### 虚拟机监视器
跑在传统OS之下，虚拟出多个计算机系统，使一个物理计算机能够虚拟出多个计算机系统给用户使用
VMM将单独的机器接口转换成很多幻象，每个这些接口(虚拟机)是一个原始的计算机系统的由小副本，并完成所有的处理器指令

此时操作系统下是VMM，VMM下是硬件，中间有隔离


