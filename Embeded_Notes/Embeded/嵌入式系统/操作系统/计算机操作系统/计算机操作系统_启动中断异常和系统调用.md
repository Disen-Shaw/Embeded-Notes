---
date updated: '2021-10-03T09:14:28+08:00'

---

# 启动、中断、异常和系统调用

## 操作系统的启动

### 操作系统的结构概述

IO设备、时钟和其他外设与内存、CPU由总线相连在一起
操作系统一开始并未放在内存中，而是放在磁盘中

POST:加电自检，寻找显卡和执行BIOS
DISK：存放OS
BIOS：基本I/O处理系统，在上电后计算机系统检测各种外设，加载相应的软件来执行
BootLoader：加载OS，让CPU进入操作系统

### 计算机内存和硬盘布局

Bootloader和OS位于硬盘之中，上点后优先执行Bootloader中的程序，然后执行操作系统
![Pasted image 20210604235902](../../../../pictures/Pasted%20image%2020210604235902.png)
Bootloader一般放在硬盘引导的地一个扇区
只要找到硬盘的地一个扇区，接可以将操作系统加载到内存中
硬盘的一个扇区是512个字节，因此bootloader只需要512字节的空间就能完成许多事情

### 开机顺序

当BIOS内存加载到Bootoader中时，CPU的控制权就已经交给了Bootloader

- Bootloader：
  - 找到硬盘起始扇区、操作系统的扇区、操作系统的长度
  - 将这片硬盘区域读取到内存中
  - 跳到OS的起始位置执行、将CPU的控制权交给OS

## 操作系统与设备和程序交互

### 面向外设

异常、中断

### 面向程序

系统调用

## 中断、异常和系统调用

### 定义

#### 系统调用

应用程序主动向操作系统发出服务请求

#### 异常

非法指令或者其他坏的处理状态，例如内存出错，栈溢出

#### 中断

来自不同的硬件设备的计时器和网络中断

### 中断、异常和系统调用相比较

在计算机运行中，内核是被信任的第三方，只有内核可以执行特权指令，为了方便应用程序

| 名称   | 源头             | 处理时间                                 | 响应                  |
| ---- | -------------- | ------------------------------------ | ------------------- |
| 中断   | 外设             | 异步，不知什么时候产生                          | 持续，对用户程序是透明的        |
| 异常   | 应用程序意想不到的行为    | 同步的，执行了某一段程序一定会产生异常                  | 杀死或者重新执行，想不到的应用程序指令 |
| 系统调用 | 应用程序主动请求操作提供服务 | 异步或者是同步的</br>返回的时间可能是异步的</br>也可能是同步的 | 等待和持续，等待服务完成后继续执行   |

### 中断和异常处理机制

- 中断是外设的事件
- 异常是内部CPU的事件
- 中断和异常迫使CPU访问一些被终端和异常服务访问的功能

#### 中断

中断需要对每项中断有一个明确的服务，类似与中断向量表一样的编号
特定的中断有特定的编号，而特定的编号有特定的地址，根据地址转条到中断处理函数中

##### 硬件

设置中断标记，cpu初始化

- 将内部、外部时间设置中断标记
- 中断事件的ID

##### 软件

- 保存当前的状态，便于后续的恢复
- 终端服务程序处理
- 清除中断标记
- 回复之前保存的处理状态

#### 异常 异常编号

- 保存现场

- 异常处理
  - 杀死产生异常的程序
  - 重新执行异常指令

- 恢复现场

### 系统调用概念

程序运行过程中会需要操作系统的接口提供相应的服务
例如应用程序调用printf()函数，会出发系统调用write()
程序访问主要是通过高层次的API接口，而不是直接进行系统调用

- Win32 API 用于Windows
- POSIX API用于POSIX-based systems，包括UNIX、Linux、MacOS
- Java API用于JAVA虚拟机(JVM)

### 系统调用实现

- 通常情况下，每个系统调用相关的序号
  - 系统调用接口根据这些序号来维护表的索引

- 系统调用接口调用内核态中预期的系统调用
  - 返回系统调用的状态和其他任何返回值

- 用户不需要知道系统调用如何实现
  - 只需要获取API了解操作系统将什么作为返回结果
  - 操作系统接口的细节大部分都隐藏在API中

应用程序直接或者间接通过一个Library的库来访问系统调用的接口，一旦访问访问这个接口，会出发`用户态`到`内核态`的转换
用户态与内核态分别为CPU所处于的一个执行状态

### 函数调用与系统调用的不同之处

函数调用的过程中在一个栈空间完成的一个参数的传递和返回，而在系统调用中，应用程序与内核有各自的堆栈，当应用程序发生系统调用时，当它切换到内核中执行时会切换堆栈，同时需要完成CPU状态的转换，这些过程都需要一定的开销

### 开销

相对于函数传递，系统调用的开销会让操作系统更加安全可靠

- 建立中断、异常、系统调用与对应服务已成关系的初始化开销
- 建立内核堆栈
- 验证参数
- 内核态映射到用户态的地址空间
- 内核态独立地址空间
