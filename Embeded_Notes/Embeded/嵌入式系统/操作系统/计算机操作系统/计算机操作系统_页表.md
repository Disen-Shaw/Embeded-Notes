---
date updated: '2021-10-03T09:15:10+08:00'

---

# 非连续内存分配 页表

## 页表

### 页表概述

页表就是一个大数组，索引指的就是页号，索引所对应的页号的内容就是对应的帧
页表的建立过程由页表完成

#### 页表的重要选项

- Flags标志为
  - dirty bit
  - resident bit
  - clock/reference bit
- 帧号：f

bit可以表示页表对应的物理页在内存中是否存在

![Pasted image 20210608003133](../../../../pictures/Pasted%20image%2020210608003133.png)
如果内存不存在，则会出现内存访问异常，操作系统进一步处理

#### 分页机制的性能问题

1. 访问一个内存单元需要两次内存访问
   - 一次用于获取页表端
   - 一次用于访问数据
2. 页表可能非常大

例如64位机器如果每页1024字节，那么一个页表的大小会很大

#### 处理办法

- 缓存
- 间接访问

### 转换后备缓冲区

![Pasted image 20210608004251](../../../../pictures/Pasted%20image%2020210608004251.png)
位于内存管理单元的TLB缓存cache缓存页表的内容
速度很快，可以并发查找，但是容量和个数有限
把经常用到的页表项放入TLB中来提升访问速度，这就不用查页表，减少一次对页表的访问，当TLB查找失败，CPU就会去查找页表，如果在页表中查找到对应的页表号，就会将其加入TLB中来缓存

类似与CPU中的cache

### 二级/多级 页表

空间上减少内存使用
类似与一层目录变成多层目录
![Pasted image 20210608005053](../../../../pictures/Pasted%20image%2020210608005053.png)
首先在寻址的时候首先寻找一级页表，在一级页表中查找出一级页表的页表项，一级页表存的值是二级页表的起始地址
找到之后在二级页表存的index加上一级页表中存储的二级页表的起始地址，形成一个二级页表中针对p2的页表项，加上之后就是物理地址

依次类推，可以形成多级页表的树状结构

### 反向页表

以物理页帧号为index查找逻辑页
![Pasted image 20210608010218](../../../../pictures/Pasted%20image%2020210608010218.png)

使页表的容量只与物理空间的大小有关，而与逻辑地址大小无关
