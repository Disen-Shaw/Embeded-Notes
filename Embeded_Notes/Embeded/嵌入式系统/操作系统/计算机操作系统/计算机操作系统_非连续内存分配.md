# 非连续内存分配
## 非连续内存分配
### 连续内存分配的缺点
+ 分配给一个程序的物理内存是连续的
+ 内存利用率低
+ 有外碎片、内碎片的问题

### 非连续分配优点
+ 一个程序的物理地址空间是非连续的
+ 更好的内存利用管理
+ 允许共享代码与数据(共享库等)
+ 支持动态加载和动态链接
### 非连续分配缺点
开销大
建立虚拟地址和物理地址之间的转换
+ 软件方案
+ 硬件方案

以下两种硬件管理机制

## 分段
### 分段介绍
计算机程序实际上是由各种段组成的
![Pasted image 20210606005851](../../../../pictures/Pasted%20image%2020210606005851.png)
主程序、子程序、共享库等形成代码的不同分段
栈区段、堆区段等也是分段

分段能够更好的分离和共享管理
![Pasted image 20210606010147](../../../../pictures/Pasted%20image%2020210606010147.png)
便于共享和管理和隔离，并保证有效的保护机制

从另一方面看，逻辑地址空间是一段连续的一维数组空间，而程序中的不同的内存段分别映射到不同的物理空间去

### 分段寻址方案
![Pasted image 20210606010916](../../../../pictures/Pasted%20image%2020210606010916.png)
一个段：一个内存块->一个逻辑地址空间
程序访问内存的地址需要
一个二元组(s,addr)
+ s：段号
+ addr：段的偏移

#### 硬件实现方案
![Pasted image 20210606011131](../../../../pictures/Pasted%20image%2020210606011131.png)
程序通过CPU执行运行的指令
通过段号找到内存的物理地址
段表为一种硬件机制，存储逻辑地址段号和物理地址段号之间的映射关系

段表操作系统在正式寻址前应该建立好
## 分页
分段机制现在用的比较少，现在主要用的分页机制
### 分段与分页的区别
在分段寻址中，段的大小是可变的
而在分页寻址中，页的大小不变

### 分页地址空间
划分物理内存至固定大小的帧
帧大小是2的幂，例如512、4096等
划分逻辑地址空间至相同大小的页
大小也是2的幂
这一过程方便硬件实现，建立逻辑页与物理页的关系

#### 帧——物理
物理内存被分割为大小相同的帧
一个内存物理地址是一个二元组(f,o)
f:帧号(F位，共有2^F个帧)
o:帧內偏移(S位，每帧有2^S字节)
因此如果知道帧号和偏移地址，可以求出实际物理地址
物理地址=2^S\*f+o
`类比stm32单片机寄存器地址映射`
![Pasted image 20210606012840](../../../../pictures/Pasted%20image%2020210606012840.png)

#### 页——逻辑
一个程序的逻辑地址空间被划分为大小相同的页
+ 页内偏移大小=帧內偏移的大小
+ 页的大小和帧的大小是一样的
+ 页号大小<>帧号大小`可能不一样`

一个逻辑地址是一个二元组(p,o)
p:页号(P位，2^个页)
o:页内偏移(S位，每页有2^S个字节)
![Pasted image 20210606013450](../../../../pictures/Pasted%20image%2020210606013450.png)

### 页寻址机制
![Pasted image 20210606013645](../../../../pictures/Pasted%20image%2020210606013645.png)
通过查页表，页号对应帧号
页表由操作系统初始化时建立

分页机制使得页内偏移的大小是固定的，便于管理硬件

页寻址机制
+ 页映射到帧
+ 页是连续的虚拟内存
+ 帧是非连续的物理内存
+ 不是所有的页都有对应的帧

好处在于有助于减少碎片


