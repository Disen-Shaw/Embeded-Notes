# 页面置换算法
## 功能目标
### 功能
当缺页中断发生时，需要调入新的页面内存已满时，选择内存当中哪个物理页面被置换

### 目标
尽可能减少页面的换进换出次数(缺页中断次数)
把未来不再使用的或者短期内较少使用的页面换出，通常只能在局部性原理指导下依据过去的统计来进行预测

### 页面锁定
用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程
实现方法是：在页表中添加锁定标志位

### 
**记录一个进程对页访问的一个轨迹**
例如(虚拟)地址跟踪(页号，位移)...
(3,0),(1,9),(4,1),(2,1),(5,3),
(2,0),(1,9),(2,4),(3,1),(4,8)
`第三个页面的第0个偏移，第一个页面的第9个偏移...`

**生成页面轨迹**
3,1,4,2,5,2,1,2,3,4替换如c,a,d,b,e,b,a,b,c,d

**模拟一个页面置换的行为并且记录产生页缺失的数量**
更少的缺失，更好的性能

## 最优页面置换算法
### 基本思路
当一个缺页发生时，对于保存在内存中的每一个逻辑页面，计算在它下一次访问之前，还需要等待多长时间，从中选择等待时间最长的那个，作为被置换的页面

这是一种理想的状况，在实际系统中是无法实现的，因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问

可以将这个算法作为别的算法的评价标准
`在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法`

![[Pasted image 20210622003522.png]]
第五次访问出现缺页中断，将d替换成e
![[Pasted image 20210622003623.png]]

## 先进先出算法(FIFO)
`first in first out`
选择在内存中驻留时间最长的页面，并将之淘汰掉
具体来说，系统维护者一个链表，记录了所有位于内存中的逻辑页面，从链表的排序来看，链首页面淘汰出局，并把新的页面添加到链表的末尾

### 性能较差
调出的页面可能是经常要访问的页面，并且会有Belady现象
FIFO算法很少单独使用
起初也是和最优页面置换算法一样，但是等到第五个e发生缺页中断后，假设在最开始的时候abcd进入链表，链表中驻留时间最长的是a，此时e将a替换掉。
![[Pasted image 20210622003522.png]]
往后会可能会不断出发缺页中断
![[Pasted image 20210622004758.png]]

## 最近最久未使用算法(LRU)
`least recently used`
### 基本思路
当一个缺页中断发生时，选择最久未使用的那个页面，并将其淘汰

它是对对最优页面置换算法的一个近似，其依据是程序的局部性原理，即在最近一段时间(最近几条指令)内，如果某些页面被频繁地访问，那么在将来的一点时间内，它们还可能会再一次频繁被访问
反过来说，如果过去某些页面长时间未被访问，那么在将来，他可能长时间也不会被访问

起初前四次还是一样的
![[Pasted image 20210622003522.png]]
c最久未被访问，因此将会把c替换掉，将之替换为e
之后以此类推
![[Pasted image 20210622005822.png]]


### 实现方法
LRU算法需要记录各个页面使用时间的先后顺序，开销比较大
两种可能的办法：
#### 链表
系统维护一个页面链表，最将刚刚使用过的页面作为首结点，最久未使用的页面作为尾结点
每一次访问内存时，找到相应的页面，把它从链表中摘下来，再移动到链表之首
每次缺页中断发生时，淘汰链表末尾的页面

#### 堆栈
设置一个活动页面栈，当访问某页面时，将此页号压入栈顶，然后，考察栈內是否有与此相同的页号，若有则抽出
当要淘汰一个页面时，总是选择栈低的页面，他就是最久未使用的。

## 时钟页面置换算法
Clock页面置换算法，LRU的近似，对FIFO的改进
### 基本思路
需要用到页表当中的访问位，当一个页面被装入内存时，该位初始化位0,然后如果这个页面被访问(读/写)，则把该位置1
把各个页面组织称环形链表(类似于钟表面)，把指针指向最老的页面(最先进来)
**`访问置1由硬件完成`**
当发生一个缺页中断时，考察指针所指向的最古老的页面

+ 若它的访问位为0,立即淘汰
+ 若访问位为1,则把改为置为0

然后指针往下移动一格，如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格

### 算法
保持一个环形页面链表保存在内存中
+ 用一个时钟(或者使用/引用)位来标记一个页面是否经常被访问
+ 当一个页面引用的时候，这个位被设置(为1)

时钟头扫遍页面寻找一个带有used bit = 0
+ 替换在一个周转内没有被引用过的页面

![[Pasted image 20210622012125.png]]
第一位代表存在位
如果为1,则代表在物理内存中是存在的
第二位为used bit
如图中的，当指针指示到page0时，used位为1,表明该位最近被访问过，随后指针顺时针往下一个节点走，并将page0的used位置0

### 效果
一开始都是一样的
![[Pasted image 20210622003522.png]]
此时abcd的used位为1
走一圈后再走时将a替换为e，根据原理以此类推

![[Pasted image 20210622013158.png]]

## 二次机会法
### 脏位
脏位其实是写位
+ 如果页进行了写操作，dirty bit会被置1
+ 如果页进行了读操作，dirty bit就是0

`这个位的也是由硬件来完成的`
修改clock算法，使它允许脏页总是在一次时钟头扫描中保留下来
通过两个位，减少置换次数
如果dirty bit和存在位都是0，这个是要找的页面

如果存在两个位都是1,则时钟指针指到它时会给它一次机会，最终减少访问硬盘的次数

### 效果
初始情况下：
![[Pasted image 20210622014503.png]]

![[Pasted image 20210622014729.png]]

## 最不常用算法(LFU)
`least frequently used`
### 基本思路
当一个缺页中断发生时，选择访问次数最少的那个页面，并将之淘汰

### 实现方法
对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加1
在发生缺页中断时，淘汰计数值最小的那个页面

### LRU和LFU的区别
LRU考察的是多久未访问，时间越短越好
LFU考察的是访问次数或者频度，访问次数越多越好

## Belady现象
### Belady现象
在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的现象

#### 原因
FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标不一致(即替换较少使用的页面)，因此，被它置换出去的页面不一定是进程不会访问的

LRU满足栈算法的特点，分配的物理页增多，命中率会提高

## LRU、FIFO、Clock的比较
LRU和FIFO本质上都是先进先出的思路，只不过LRU是针对页面的最近访问时间来进行排序，所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了)

而FIFO是针对页面进入内存时间来进行排序，这个时间是不固定的，所以各个页面之间的先后顺序是固定的

如果一个页面在进入内存后没有被访问，那么它的最近访问时间就是进入内存的时间，换句话说如果内存当中的所有页面都未曾访问过，那么LRU算法就退化为FIFO算法

LRU算法性能较好，但系统开销大，FIFO算法系统开销小，但可能会发生Belady现象，因此折衷的办法就是Clock算法，在每一次页面访问时，都不必去动态的调整该页面在链表中的顺序，而仅仅是做一个标记，然后等到发生缺页中断的时候，在把它移动到链表的末尾
对于内存中那些未被访问的页面，Clock算法的表现和LRU一样好，而对于那些曾被访问过的页面，他不能像LRU算法那样，记住他们的准确位置







