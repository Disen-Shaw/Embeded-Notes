# 连续内存的分配
## 内存碎片问题
### 外部碎片
在分配单元时未使用内存  

### 内部碎片
在分配单元中的未使用内存

## 分区的动态分配
### 简单的内存管理方法
内存：当一个程序准许运行在内存空间中时，分配一个连续的区间  
内存数据：分配一个连续的内存区间给运行的程序以访问数据  
对于这种内存空间的管理，会有一些数据结构的算法  

### 分配策略
#### 首次适配算法
就是从第一个满足空间的大小的块来分配
空闲块
![[Pasted image 20210605142349.png]]
为了分配n字节，使用地一个可用空闲块以致快的尺寸比n大  
例如为了分配400字节，使用地一个可用空闲块  

简单实现：  
需求：  
按地址分配的空闲块列表  
分配需要寻找一个合适的分区  
重分配需要检查，看是否自由分区能合并与相邻的分区  
优点：  
简单、易于产生更大的空闲块，向着地址空间结尾(从前往后的分配)  
劣势：  
容易产生外部碎片  
有很多不确定性  

#### 最佳适配
![[Pasted image 20210605143104.png]]
想对于首次适配算法的改进  
找到最适合的满足需求的空闲块  

例如：为了分配400字节，使用第三个可用的空闲块(最适合)  

基本原理：  
为了避免分割大的空闲块  
为了最小化外部碎片产生的尺寸  
需求：  
按尺寸排列的空闲块列表  
分配需要寻找一个合适的分区  
重分配需要搜索及合并与相邻的空闲分区  
优势：大概大部分分配是小尺寸时非常有效，而且比较简单  
劣势：  
容易产生外部碎片  
若要重新分配，这个过程会比较慢  
容易产生很多没用的微小碎片  

#### 最差适配
![[Pasted image 20210605143838.png]]
为了分配n字节，使用最大可用空闲块，以致块的尺寸比n大  
例如为了分配400字节，使用第二可用空闲快  
基本原理：  
为了避免有太多微小的碎片  
需求：  
按尺寸排列的空闲块列表  
分配很快(获得最大的分区)  
重新分配时，如果有，需要合并于相邻的空闲分区，然后调整空闲块列表  
优势：  
假如分配-\*是中等尺寸效果最好  
劣势：  
重分配慢  
外部碎片  
易于破碎打的空闲块以致打分区无法被分配  

## 压缩式碎片处理
![[Pasted image 20210605144655.png]]
+ 重置程序以合并孔洞
+ 要求所有程序是动态可重置的

挪动时机  
不可以在程序运行的时候去挪动，会导致地址对一个错误的情况  
可以在程序的等待时进行挪动  

即使这样，挪动的开销也是非常大的，甚至可能导致系统总体崩溃  

## 交换式碎片整理swap
操作系统把硬盘当作内存的一个备份  
![[Pasted image 20210605145039.png]]  
运行程序需要更多内存  
抢占等待的程序，回收它们的内存  
问题是将那些程序进行交换、并且什么时候进行交换  
