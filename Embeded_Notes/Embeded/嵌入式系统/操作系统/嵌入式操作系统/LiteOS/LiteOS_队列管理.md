---
date updated: '2021-10-01T08:42:44+08:00'

---

# LiteOS 队列

## 基本概念

队列又称消息队列，是一种常用于 `任务间通信` 的数据结构\
队列接收来自任务或中断的不固定长度消息，并根据不同的接口确定传递的消息是否存放在队列空间中

任务能够从队列里面读取消息

- 当队列中的消息为空时，挂起读取任务
- 当队列中有新消息时，挂起的读取任务被唤醒并处理新消息。

任务也能够往队列里写入消息

- 当队列已经写满消息时，挂起写入任务
- 当队列中有空闲消息节点时，挂起的写入任务被唤醒并写入消息如果将读队列和写队列的超时时间设置为0，则不会挂起任务，接口会直接返回，这就是非阻塞模式。

消息队列提供了异步处理机制，允许将一个消息放入队列，但不立即处理。同时队列还有缓冲消息的作用。

### LiteOS 队列特性

LiteOS中使用队列实现任务异步通信，具体有如下特性

- 消息以队列先进先出的方式排队，支持异步读写
- 读队列和写队列都支持超时机制
- 每读一条消息，就会将该消息设置为空闲
- 发送消息类型由通信双方约定，可以允许不同长度(不超过队列的消息节点大小)的消息
- 一个任务能够从任意一个消息队列接收和发送消息
- 多个任务能够从同一个消息队列接收和发送消息
- 创建队列时所需的队列空间，
  - 默认支持接口内系统自行动态申请内存的方式
  - 同时也支持将用户分配的队列空间作为接口入参传入的方式

## 队列运作机制

队列控制块

```c
typedef enum {
	OS_QUEUE_READ = 0,
	OS_QUEUE_WRITE = 1,
	OS_QUEUE_N_RW = 2
}QueueReadWrite;

typedef struct {
	UINT8       *queueHandle;                    /* 队列指针 */
    UINT8       queueState;                      /* 队列状态 */
    UINT8       queueMemType;                    /* 创建队列时内存分配的方式 */
    UINT16      queueLen;                        /* 队列中消息节点个数，即队列长度 */
    UINT16      queueSize;                       /* 消息节点大小 */
    UINT32      queueID;                         /* 队列ID */
    UINT16      queueHead;                       /* 消息头节点位置（数组下标）*/
    UINT16      queueTail;                       /* 消息尾节点位置（数组下标）*/
    UINT16      readWriteableCnt[OS_QUEUE_N_RW]; /* 数组下标0的元素表示队列中可读消息数，                              
                                                    数组下标1的元素表示队列中可写消息数 */
    LOS_DL_LIST readWriteList[OS_QUEUE_N_RW];    /* 读取或写入消息的任务等待链表， 
                                                    下标0：读取链表，下标1：写入链表 */
    LOS_DL_LIST memList;                         /* CMSIS-RTOS中的MailBox模块使用的内存块链表 */
}LosQueueCB;
```

每个队列控制块中都含有队列状态，表示队列的使用情况

- OS_QUEUE_UNUSER：队列没有被使用
- OS_QUEUEINUSED：队列被使用中

每个队列控制块中都含有创建队列的分配方式

- OS_QUEUE_ALLOC_DYNAMIC：创建队列时所需的队列空间，由系统自行动态申请内存获取
- OS_QUEUE_ALLOC_STATIC：创建队列时所需的队列空间，由接口调用者自行申请后传入接口

## 队列运作原理

创建队列时，创建队列成功会返回队列ID

在队列控制块中维护着一个消息头节点位置Head和一个消息尾节点位置Tail来，用于表示当前队列中消息的存储情况。Head表示队列中被占用的消息节点的起始位置。Tail表示被占用的消息节点的结束位置，也是空闲消息节点的起始位置。队列刚创建时，Head和Tail均指向队列起始位置。

写队列时，根据readWriteableCnt[1]判断队列是否可以写入，不能对已满（readWriteableCnt[1]为0）队列进行写操作。写队列支持两种写入方式：

- 向队列尾节点写入，也可以向队列头节点写入。尾节点写入时，根据Tail找到起始空闲消息节点作为数据写入对象，如果Tail已经指向队列尾部则采用回卷方式。
- 头节点写入时，将Head的前一个节点作为数据写入对象，如果Head指向队列起始位置则采用回卷方式。

读队列时，根据readWriteableCnt[0]判断队列是否有消息需要读取，对全部空闲（readWriteableCnt[0]为0）队列进行读操作会引起任务挂起。

- 如果队列可以读取消息，则根据Head找到最先写入队列的消息节点进行读取。
- 如果Head已经指向队列尾部则采用回卷方式。

删除队列时，根据队列ID找到对应队列，把队列状态置为未使用，把队列控制块置为初始状态。如果是通过系统动态申请内存方式创建的队列，还会释放队列所占内存。

![[Pasted image 20210907111936.png]]

上图对读写队列做了示意，图中只画了尾节点写入方式，没有画头节点写入，但是两者是类似的。

[[LiteOS_队列管理_API]]
