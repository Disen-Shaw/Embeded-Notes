# LiteOS 异常接管
## 基本概念
异常接管是操作系统对运行期间发生的异常情况（芯片硬件异常）进行处理的一系列动作，例如

+ 打印异常发生时当前函数的调用栈信息
+ CPU现场信息
+ 任务的堆栈情况等。

异常接管作为一种调测手段，可以在系统发生异常时给用户提供有用的异常信息，譬如
+ 异常类型
+ 发生异常时的系统状态等，

方便用户定位分析问题

Huawei LiteOS的异常接管，在系统发生异常时的处理动作为：  
显示异常发生时正在运行的任务信息（包括任务名、任务号、堆栈大小等），以及CPU现场等信息。  

针对某些 `RISC-V` 架构的芯片，对内存 size 要求较高的场景，LiteOS 提供了极小特性宏`LOSCFG_ARCH_EXC_SIMPLE_INFO`
（Kernel --> Exception Management --> Enable Exception Simple Info  
用于裁剪多余的异常提示字符串信息，但是仍然保留发生异常时的CPU执行环境的所有信息。

## 运作机制
每个函数都有自己的栈空间，称为栈帧。调用函数时，会创建子函数的栈帧，同时将函数入参、局部变量、寄存器入栈。栈帧从高地址向低地址生长。

以ARM32 CPU架构为例，每个栈帧中都会保存PC、LR、SP和FP寄存器的历史值。
### 堆栈分析
#### LR寄存器
链接寄存器，指向函数的返回地址
#### R11
可以用作通用寄存器，在开启特定编译选项时可以用作帧指针寄存器FP，用来实现栈回溯功能
#### GNU编译器
默认将R11作为存储变量的通用寄存器，因而默认情况下无法使用FP的栈回溯功能。
为支持调用栈解析功能，需要在编译参数中添加 `-fno-omit-frame-pointer` 选项  
提示编译器将R11作为FP使用
#### FP寄存器
帧指针寄存器，指向当前函数的父函数的栈帧起始地址。利用该寄存器可以得到父函数的栈帧，从栈帧中获取父函数的FP，就可以得到祖父函数的栈帧，以此类推，可以追溯程序调用栈，得到函数间的调用关系。

</br>
当系统发生异常时，系统打印异常函数的栈帧中保存的寄存器内容，以及父函数、祖父函数的栈帧中的LR、FP寄存器内容，用户就可以据此追溯函数间的调用关系，定位异常原因。  

![[Pasted image 20210907102709.png]]

图中不同颜色的寄存器表示不同的函数。可以看到函数调用过程中，寄存器的保存。通过FP寄存器，栈回溯到异常函数的父函数，继续按照规律对栈进行解析，推出函数调用关系，方便用户定位问题。

