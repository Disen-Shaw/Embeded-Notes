# DS18B20温度传感器
![[Pasted image 20210530182601.png]] 
## 简介
美国DALLAS半导体公司推出的第一片支持`一线总线`接口的温度传感器
单总线通常要求外接一个5K的上拉电阻
### 优点
+ 微型化
+ 低功耗
+ 高性能
+ 抗干扰能力强
+ 简单易用

| 特性         | 说明                                                                        |
| ------------ | --------------------------------------------------------------------------- |
| 适应电压     | 3.0V-5.0V                                                                   |
| 总线接口     | 单线                                                                        |
| 支持功能     | 多点组网，多个DS18B20可以并联在唯一的三线上，实现组网多点测温               |
|              | 使用过程不需要外围元器件                                                    |
| 测量温度     | -55-+155度                                                                  |
| 可编程分辨率 | 9-12位</br>9位分辨率93.75ms内把温度转化为数字</br>12位分辨率最多750ms内转化 |
| 测量结果     | 直接输出温度信号                                                                            |


### 应用场景
符合温度特性的位置

### 封装
1. 三脚TO直插式(如示意图)
2. 八脚SOIC贴片封装

![[Pasted image 20210530182842.png]]
[具体](http://cdn.sparkfun.com/datasheets/Sensors/Temp/DS18B20.pdf)

## 控制
### 使用顺序
+ 初始化DS18B20
+ ROM的一些指令
+ 内存的一些指令
+ 读取温度信息


### 详细信息
#### 内部ROM
8位CRC码、48位序列号、8位产品类型标号
ROM中的序列号出厂前就被光刻好的，可以看做是DS18B20的地址序列号
让每一个DS18B20都不相同，实现一个总线挂载多个DS18B20
64位ROM指令

| 十六进制指令 | 指令含义                                                                                        |
| ------------ | ----------------------------------------------------------------------------------------------- |
| 0X33         | 读ROM  ：读DS18B20温室传感器内部的编码(64位地址)                                                |
| 0X55         | 匹配ROM：发出此命令之后发出64位ROM编码，访问单线上的DS18B20，并使其做出响应，为下一步读写做准备 |
| 0XF0         | 搜索ROM：确定挂接在同一总线上DS18B20的个数，识别64位ROM的地址，为操作器件做下一步准备           |
| 0XCC         | 跳过ROM：忽略64位ROM的地址，直接向传感器发温度变换命令，适用于一个从机工作                      |
| 0XEC         | 告警搜索命令：执行后只有温度超过上限或者下限，芯片才做出反应                                    |

当主机需要对众多在线DS18B20中的某一个进行操作，首先应该将主机逐个与DS18B20挂接，读出其序列号
再将所有的DS18B20挂接到总线上，单片机发出匹配ROM命令(0X55)，然后由主机提供64位序列之后的操作就是针对该DS18B20的

如果主机只对一个DS18B20进行操作，就不需要读取ROM编码和匹配ROM编码，只要用跳过ROM(0XCC)命令，就可以进行下面的温度转换和读取操作

RAM和EEPROM

| 十六进制指令 | 指令含义                                                                                   |
| ------------ | ------------------------------------------------------------------------------------------ |
| 0X44         | 温度转换，启动DS18B20温度转换，根据提到的转换时间进行延时，结果存入内部9字节的RAM中        |
| 0XBE         | 度暂存器，读内部RAM中9字节的温度数据                                                       |
| 0X4E         | 写暂存器，发出向内部RAM的2，3字节上写 上、下限温度数据命令、紧跟该命令后发送两个字节的数据 |
| 0X48         | 复制暂存器，将RAM中的第2，3字节的内容复制到EEPROM中                                        |
| 0XB8         | 重调EEPROM，将EEPROM中的内容恢复到RAM的第3，4字节                                          |
| 0XB4         | 读供电方式，读DS18B20的供电模式</br>寄生供电时，DS18B20发0</br>外接电源供电时，DS18B20发1  |


高速暂存寄存器RAM由9个字节的存储器构成

| 第几个字节 | 硬件功能        |
| ---------- | --------------- |
| 0          | 温度值低位(LSB) |
| 1          | 温度值高位(MSB) |
| 2          | 高温限值        |
| 3          | 低温限值        |
| 4          | 配置寄存器      |
| 5          | 保留            |
| 6          | 保留            |
| 7          | 保留            |
| 8          | CRC校验         |

温度存储格式

| 位  | 真值 | 位  | 真值 | 位  | 真值 | 位  | 真值 | 位  | 真值 | 位  | 真值 | 位  | 真值 | 位  | 真值 |
| --- | ---- | --- | ---- | --- | ---- | --- | ---- | --- | ---- | --- | ---- | --- | ---- | --- | ---- |
| 7   | 2^3  | 6   | 2^2  | 5   | 2^1  | 4   | 2^0  | 3   | 2^-1 | 2   | 2^-2 | 1   | 2^-3 | 0   | 2^-4 |
| 15  | S    | 14  | S    | 13  | S    | 12  | S    | 11  | S    | 10  | 2^6  | 9   | 2^5  | 8   | 2^4  |


出厂默认配置12位，最高位为符号位，即此时温度值为11位
单片机读取数据一次会读出两个字节共16位，读完后将低11位的二进制数转化为十进制再乘0.0625，就是所测的实际温度
判断温度的正负，前五位为符号位，一起变，所以只看11位就可以了
前5位为1时，读取的温度为负数，且测到的数值需要取反加1再乘0.0625，才能得到温度值
前五位为0时，读取温度为正值，将检测到的数值直接乘0。0625就可以得到温度值

### 时序
#### 初始化
将数据线置高电平
延时
数据线拉到低电平
延时(480~960)us
数据线拉到高电平1
延时等待，如果初始化成功，则在15~60ms内产生一个由DS18B20返回的低电平0
若MCU读取到低电平，还要进行延时，延时时间从发出高电平算起至少480us
将数据线再次拉高结束初始化

#### DS18B20写数据
数据线先置0
延时确定时间为15us
按从低到高的顺序发送数据(一次发一位)
延时45us
将数据线拉到高电平1
重复前面的几个步骤，直到发送完最后一个数据位
最后将数据线拉高

#### DS18B20读数据
将数据线拉高为1
延时2us
将数据线拉低到0
延时6us
将数据线拉高为1
延时4us
读取数据线的状态得到一个状态位，并处理数据
延时30us
重复前面的操作，直到读完字节


