# Git 基础内容

## 获取 Git 仓库

通常有两种获取 Git 项目仓库的方式：

- 将尚未进行版本控制的本地目录转换为 Git 仓库
- 从其它服务器 **克隆** 一个已存在的 Git 仓库

### 在已经存在目录中初始化仓库

执行

```shell
git init
```

创建一个 `.git` 的子目录中，含有初始化 Git 仓库中所有的必须文件，这些文件是 Git 的骨干

此时只是初始化操作，项目文件还没有被跟踪，如果一个已存在文件的文件夹（而非空文件夹）中进行版本控制\
应该开始追踪这些文件并进行初始提交\
可以通过 `git add` 命令来指定所需的文件来进行追踪，然后执行 `git commit`

```shell
git add *.c
git add LICENSE
git commit -m 'initial project version'
```

### 克隆现有的仓库

要用到 `git clone` 命令，默认远程 Git 仓库中的每一个文件的每一个版本都能被拉去下来

```shell
git clone <url>
```

命令在本地建立一个 `<url>` 文件名的文件夹\
也可以在本地另起名进行克隆

```shell
git clone <url> new_name
```

Git 支持多种数据传输协议，也可以使用 `git://` 协议或者使用 SSH 传输协议\
比如 `user@server:path/to/repo.git`

## 记录每次更新到仓库

现在机器上有了一个 **真实项目** 的 Git 仓库，并从这个仓库中检出了所有文件的 **工作副本**\
通常会对这些文件做些 **修改**，每当完成了一个阶段的目标，想要将记录下它时，就将它 **提交到仓库**

工作目录下的每一个文件不外乎两种状态：

- 已跟踪：已经被被纳入版本控制的文件，在上一次快照中有它们的记录\
  工作一段时间之后，它们的状态可能是
  - 未修改
  - 已修改
  - 已放入暂存器
- 未跟踪：未被加入版本控制的文件

### 检查当前文件状态

查看哪些文件处于什么状态

```shell
git status
```

### 跟踪新的文件

使用 `git add` 开始跟踪一个文件，例如

```shell
git add README.md
```

此时再运行 `git status` 时，会看到 `README.md` 文件已经被追踪，并且处于暂存状态

### 暂存已修改文件

已经跟踪的文件的内容发生了变化，但是还没有放到暂存区\
要暂存这次更新，需要运行

```shell
git add xxx
```

`git add` 是个多功能的命令

可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等

应将之理解为：`“精确地将内容添加到下一次提交中” 而不是 “将一个文件添加到项目中”`

### 状态预览

`git status` 命令的输出十分详细，但其用语有些繁琐\
Git 有一个选项可以缩短状态命令的输出，这样可以以简洁的方式查看更改

如果使用 `git status -s` 命令或 `git status --short` 命令，将得到一种格式更为紧凑的输出

- 新添加的未跟踪文件前面有 `??` 标记
- 新添加到暂存区中的文件前面有 `A` 标记
- 修改过的文件前面有 `M` 标记

### 忽略文件

一般情况下总会有文件不需要纳入 Git 的管理，例如 c语言 的中间文件 `.o` 和一些日志文件等\
这种情况下，可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件的模式

`.gitignore` 语法支持 [正则表达式]，其中

- 所有空行或者以 `#` 开头的行都会被 Git 忽略
- 可以使用标准的 `glob` 模式匹配，它会递归地应用在整个工作区中(正则表达式)
- 匹配模式可以以（`/`）开头防止递归
- 匹配模式可以以（`/`）结尾指定目录
- 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（`!`）取反

```gitignore
# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a
# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO
# 忽略任何目录下名为 build 的文件夹
build/
# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```

### 查看已暂存和未暂存的修改

如果 `git status` 命令的输出过于简略，并且想知道具体修改了什么地方，可以用 `git diff` 命令

通常使用这个命令回答两个问题：

- 当前做的哪些更新尚未保存
- 哪些更新已暂存并准备好下次提交

相较于`git status`，`git diff` 能通过文件补丁的格式 **更加具体** 地 **显示哪些行发生了改变**

若要查看已暂存的将要添加到下次提交里的内容\
可以用 `git diff --staged` 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异

`git diff` 本身只显示 **尚未暂存** 的改动，而不是自上次提交以来所做的所有改动\
所以有时候一下子暂存了所有更新过的文件，运行 `git diff` 后却什么也没有，就是这个原因

