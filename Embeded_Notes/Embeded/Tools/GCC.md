 # GCC相关知识
> 具体要查GNU手册
## 科普知识
GCC是可移植编译器，从微处理器到大型64位处理器
支持交叉编译，从一个平台可以编译出另一个平台的可执行文件
如果要在C中加入其他语言，只要在软件中加一个前端

编译过程是由多个不同的工具来完成的
+ 预处理   生成.i文件 使用cpp工具
+ 编译  	生成.o文件 使用ccl工具
+ 汇编	生成.s文件 使用as工具
+ 连接	生成可执行文件 使用ld工具
## GCC使用
gcc参数选项(-xxx)对程序的编译没有影响
### 选项
#### 警告参数
-Wall:显示所有警告
`all包括：`
`-Wcomment：注释是否嵌套，标准情况下不允许注释嵌套 常用#if 0 #endif`
`-Wformat：检测printf和scanf中传值是否正确`
`-Wunused：检测是否含有没有使用的变量`
`-Wimplicit：使用未声明的函数或者变量`
`-Wreture-type：检查返回值`
`-Werror：将所有警告当成错误处理`
`-Wcast-align：地址不需要对齐的指针指向了一个需要地址对齐的变量地址，产生警告`
其他警告参数
`-W`
`-Wconversion`
`-Wshadow`
`-Wcast-qual`
`-Wwrite-strings`
`-Wtraditional`
这些警告不一定会有问题，但是有可能会有问题
#### 交叉编译选项
-b：定义目标机器
-V：定义所执行GCC的版本号
-m：定义一个CPU家族内的型号(例如arm中的-mcpu=xxx等)
#### 链接器参数选项
-Map mapfile:指定内存分配映像文件名，通常以map作为后缀
-cref:生成交叉引用表，如果能生成map文件，则交叉引用表存在于map文件的最后
-Tscriptfile:使用链接描述文件来代替默认的链接描述(类比STM32中的ld文件)
#### 其他参数

-IINC:包含头文件文件夹
-L：包含库所在的目录
-llibname：装载时，连接名为name的.a函数库
-o:指定生成文件名
-v:输出编译的详细信息
-c:编译文件，生成.o文件
-E：只预处理
-Dxxx：宏定义xxx
-Q：编译过程中统计数据和每一个函数名
-g：将一些可调试信息存放在目标文件和可执行文件中

-pg：可执行文件可以使用gprof来查看程序的函数详细状况

--target-help：列出GCC支持的所有类型
-std=xxxx:采用什么标准来编译
-static：强制优先使用静态库
**-ansi:采用ANSI标准编译
-pedantic：不符合ANSI/ISOC语言别的标准代码时会提出警告**
-D_GNU_SOUECE:宏定义GNU_SOURCE
-save-temps:保存中间结果
#### 基本使用
include "xx" 从当前目录下寻找文件
include \<xx> 从编译器根目录下寻找文件
系统头文件目录一般是
/usr/include
/usr/local/incude

##### 链接次序注意 
潜规则：如果一个目标文件包含了一个函数的定义，那么就应该放在调用这个函数的其他文件的后面
include "" 从当前目录下寻找文件
**定义在后，调用在前**

如果已经包含了所有文件，仍然报出有函数未定义，可以适当颠倒位置。

#### 连接外部库
使用-L来指定库文件目录
##### 静态库
静态库文件扩展名通常为.a Linux .lib windows
通常使用ar工具将文件捏合成库文件
~~~shell
ar -crs libxxx.a xxx.o xxx.o
~~~
**静态库会把所有的函数都拷贝到工程中，生成的可执行文件占用内存较多**
##### 动态库(共享库)
动态库文件拓展名通常为.so Linux .dll windows
优点：
+ 共享内存，减少程序对内存的浪费
+ 链接时定位一个表中的函数，而不是把文件连接到可执行文件中
+ 调用动态库中的函数时会将函数代码拷贝到内存中
	+ 先找磁盘，在导入到内存
	+ 这样的特性导致主程序相比于静态库会更小

+ 操作系统提供虚拟内存机制，使得如果在内存中有多个进城调用一个动态库，只需要在内存中留下一个拷贝，还是减少对内存的浪费

**GCC会在编译过程中优先调用动态库中的代码**
缺点：
可执行文件执行时不能脱离动态库
使用方式：
~~~c++
gcc -fPIC -shared -o libxxx.so xxx.c
~~~

但是使用动态库需要将动态库提前放置到环境变量中
### 多文件编译的好处
若是单独的一个大文件工程
每更改一个微小的细节，都要重新编译整个工程
如果将工程做成多文件，只需要重新编译更改的文件
通过链接器再链接成可执行文件

在编译大型文件的过程中，可以使用[Makefile](Makefile.md)来指定规则

### 预处理
简单的字符替换，将宏定义进行替换
GNU的与处理器为cpp
#### 条件编译
~~~c
#ifdef xxx
	c语句
#endif
~~~
在编译时，如果不加上相应的宏定义，就不会对这条语句进行编译
如果加上 -Dxxx 就会执行下面的c语句
-D也可以向函数中传入参数
例如程序
~~~c
#include <stdio.h>
void main()
{                                                         
 	printf("hello,world %d",var);
}
~~~
执行 gcc -Dvar=100 main.c -o main
不会报错，执行会输出结果100
如果不定义，则编译时会报错

### 优化
编译器优化方式有以下几种：
+ 利用计算的中间结果，避免反复计算(CSE技术)
+ 内嵌函数，多次重复循环的语句调用函数，编译器会把函数代码指令直接**拷贝**到循环中(FL技术)
+ 循环加速，减小循环判断，直接进行循环内的操作
+ 机器指令方面的优化(寻找机器码最佳的次序排列)，在不增加代码长度的情况下提高运行速度(编译慢)

对于嵌入式硬件系统，受制于内存限制，即使要运行慢一些，也要将可执行文件做的相对小一些
#### GCC优化
-OLEVEL：level为0到3,等级越高，优化强度越大
`优化等级越高，编译速度可能会越慢，而且运行速度也不一定是最快的，debug会更复杂`
-O0：不优化
-O2：生产系统
-O3：最高等级，卓越品质，但是代码质量要高，否则会有一些问题
**并不是优化等级越高，运行速度越快**
**-funroll-loops：循环优化，代码中有大量循环时进行优化**
-Os:对目标文件的大小进行优化
有些情况下，优化能够检测出潜在的Bug
-s：删除符号表中的重定向和符号表，减少执行文件的尺寸

### GCC编译C++
GNU的GCC将C++语言直接编译成汇编
实用g++来进行编译，和GCC的实用选项基本相同，混合编程比较容易
最后链接时需要使用g++来链接，否则可能会出现**啥啥啥未定义的错误**

## 其他命令和工具
### file命令
file 可执行文件，查看文件的详细信息

### nm
查看符号表，查看所用的函数是在哪一个目标文件中被定义的
T：函数在目标文件中已经被定义
U：函数在目标文件中没有被定义

### ldd
显示动态库依赖，可用于可执行文件或者其他的动态库

### gprof

### gcov
gcov 源文件，生成源文件的执行情况